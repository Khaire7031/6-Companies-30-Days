class Solution {

    public int mostProfitablePath(int[][] edges, int bob, int[] amounts) {
        Node[] nodes = buildTree(edges, amounts);

        List<Node> level = new ArrayList<>();

        Node bobNode = nodes[bob];

        int max = Integer.MIN_VALUE;

        level.add(nodes[0]);

        while(!level.isEmpty()){
            List<Node> nextLevel = new ArrayList<>();
            for (Node node : level) {
                int amount = bobNode == node ?  node.amount/2 : node.amount;
                node.income = (node.parent == null ? 0 : node.parent.income) + amount;

                // leaf
                if(node.children.isEmpty()) max = Math.max(node.income, max);

                nextLevel.addAll(node.children);
            }

            // bob has visited this node, so the gate is open now
            bobNode.amount = 0;
            if(bobNode.parent != null) bobNode = bobNode.parent;

            level = nextLevel;
        }

        return max;

    }

    private Node[] buildTree(int[][] edges,  int[] amounts) {
        int n = amounts.length;

        // for O(1) lookup
        Map<Integer, Set<Integer>> neighbors = new HashMap<>();
        for (int[] edge : edges) {
            neighbors.computeIfAbsent(edge[0], _k -> new HashSet<>()).add(edge[1]);
            neighbors.computeIfAbsent(edge[1], _k -> new HashSet<>()).add(edge[0]);
        }


        Node[] nodes = new Node[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node(amounts[i]);
        }

        List<Integer> level = new ArrayList<>();

        level.add(0);

        // build tree level by level
        while(!level.isEmpty()){
            List<Integer> nextLevel = new ArrayList<>();
            for (int i : level) {
                Node node = nodes[i];
                for (int u : neighbors.get(i)) {
                    Node other = nodes[u];
                    node.children.add(other);
                    other.parent = node;

                    // we already added this edge and its inverse (the parent), so we remove its inverse from the map
                    neighbors.get(u).remove(i);

                    nextLevel.add(u);
                }
            }
            level = nextLevel;
        }

        return nodes;
    }

    private class Node{
        int amount;
        List<Node> children = new ArrayList<>();
        Node parent;
        int income;

        public Node(int amount) {
            this.amount = amount;
        }
    }
}
